#### 5.4.2 提交之前任期的日志条目

正如`5.3节`中描述的那样，只要一个日志条目被存储在了大多数的`Server`上，`Leader`就知道属于当前任期的条目已经提交了。如果`Leader`在提交之前就崩溃了，将来的`Leader`会尝试着继续完成复制日志。然而，新`Leader`并不能马上确定，一个来自前一任期的条目已经被提交，虽然该条目已经存储到了大多数`Server`上。`图-8`说明了一种情况，一个存储在了大多数`Server`上的日志条目仍然被新上任的`Leader`覆盖了。

![](/assets/Figure-8-Leader-cannot-determine-commitment-using-log-entries-from-older-terms.png)

`图-8：如图的时间序列说明了为什么Leader不能通过之前任期的日志条目判断它的提交状态。在(a)中，S1是Leader并且部分复制了索引2上的日志条目。在(b)中 S1崩溃了；S5 通过S3、S4 和自己的投票赢得了选举，并且在索引2上接收了另一个日志条目。在(c)中S5崩溃了，S1重启了，通过S2、S3 和自己的投票赢得了选举，并且继续索引2处的复制，这时任期2的日志条目已经在大部分服务器上完成了复制，但是还并没有提交。在(d)中，如果S1崩溃了，S5会通过S2、S3、S4 的投票成为Leader，然后用它自己在任期3的日志条目覆盖掉其他Server的日志条目。然而，如果S1在崩溃之前，它当前任期在大多数Server上复制了一个日志条目，就像在(e)中那样，那么这个条目就会被提交（S5就不会赢得选举）。在这时，之前的日志条目就会正常被提交。`

为了消除`图-8`中描述的问题，`Raft`从来不会通过计算复制的日志条目数，来提交之前任期的日志条目。只有`Leader`当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。在某些情况下，`Leader`可以安全的知道一个旧的日志条目是否已经被提交（例如，通过观察该条目是否存储到所有`Server`上），但`Raft`使用了一种更加保守的方法来简化问题。

